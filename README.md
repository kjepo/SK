# SK

A small implementation of David Turner's graph reduction algorithm from
"A new implementation technique for applicative languages", Software Practice
& Experience 1979.

I worked on this a little bit when I was a grad student at UCSC but didn't
implement the abstraction algorithm (a.k.a. lambda lifting).  Now, 32 years
later, I wrote it and 
the aim is to write a simple parser which can generate an abstract syntax tree
which is then rewritten to a combinator graph and translated to C code for
compilation and execution.

The program currently computes the factorial function by reducing a combinator
graph generated by the Haskell program `lift.hs`.

The input is a function definition fac = Î»x. if x=0 then 1 else x*fac(x-1) which is encoded
```
\x -> cond (eq x 0) 1 (times x (fac (minus x 1)))
```

This is represented as an abstract syntax tree:
```
Abs "x" (App (App (App (Var "cond") (App (App (Var "eq") (Var "x")) (Number 0))) (Number 1)) (App (App (Var "times") (Var "x")) (App (Var "fac") (App (App (Var "minus") (Var "x")) (Number 1)))))
```

The abstraction takes that and generates a combinator graph:
```
S (C (B cond (C (B eq I) 0)) 1) (S (B times I) (B fac (C (B minus I) 1)))
```

which is then simplified to
```
S (C (B cond (C eq 0)) 1) (S times (B fac (C minus 1)))
```

which is then printed as C-code:
```
Noderef facp = mkapply(mkapply(mkS(), mkapply(mkapply(mkC(), mkapply(mkapply(mkB(), mkCOND()), mkapply(mkapply(mkC(), mkEQ()), mknum(0)))), mknum(1))), mkapply(mkapply(mkS(), mkTIMES()), mkapply(mkapply(mkB(), fac), mkapply(mkapply(mkC(), mkMINUS()), mknum(1)))));
```

which I can insert in the `init` function in `ski.c` and compile and run and get a result.

## How to use `ski.c`

There's no makefile, but you can simply type `make ski` to generate the executable.
It currently computes `range 10` which should output `10:9:8:7:6:5:4:3:2:1:nil`, i.e.,
the representation of `[10,9,8,7,6,5,4,3,2,1]`.

The program understands a couple of tracing commands: `ski -t` prints the combinator graph on stdout during execution.
The more sophisticated `ski -d graph.dot` outputs GraphViz code to the supplied file (here, `graph.dot`).
If you have GraphViz installed, run `dot -Tjpg -O graph.dot` to generate a bunch of JPEG files, one per execution step.
A lot of these graphs are identical, so I recommend that you prune them, for instance with `fdupes -rdN .`

My original paper listing from 1990 is scanned as a PDF file.

## Grammar

```
program ::= definition program
program ::= definition

definition ::= "fn" IDENT "=" exprlist ";"

exprlist ::= expr exprlist
exprlist ::= expr

expr ::= "\" IDENT "->" expr
expr ::= "if" expr "then" expr "else" expr
expr ::= expr "+" term
expr ::= expr "-" term

term ::= term "*" factor 
term ::= term ":" factor
term ::= term "=" factor

factor ::= "(" exprlist ")"
factor ::= IDENT
factor ::= NUM
factor ::= "true"
factor ::= "false"
```

Example:

```
fn length = \list -> if (null list) then 0 else 1 + length (tail list)
```

```
tokens: ID, NUM, ';', '(', ')', '+', '-', '*', '=', '\', '->', 'if', 'then', 'else', 'fun', 

pre-defined functions: null, head, tail
```

```
lines           ::= definition lines
lines           ::= expr lines
line            ::= empty

definition      ::= "fun" identlist "=" expr ";"

identlist       ::= ID identlist
identlist       ::= ID

expr            ::= "\" ID "->" expr
expr            ::= "if" expr "then" expr "else" expr
expr            ::= expr "+" term
expr            ::= expr "-" term
expr            ::= term

term            ::= term "*" factor
term            ::= factor

factor          ::= simple factor
factor          ::= simple

simple          ::= '(' expr ')'
simple          ::= ID
simple          ::= INT
```

EBNF:

```
lines           ::= { ( definition | expr ) }
definition      ::= "fun" ID { ID } "=" expr ";"
expr            ::= "\" ID "->" expr
expr            ::= "if" cond "then" expr "else" expr
cond            ::= "!" cond
cond            ::= expr [ "==" expr ]
cond            ::= expr [ "!=" expr ]
cond            ::= expr [ "<" expr ]
cond            ::= expr [ ">" expr ]
expr            ::= term { "+" term }
expr            ::= term { "-" term }
term            ::= factor { "*" factor }
term            ::= factor { ":" factor }  // right-associative
term            ::= "-" factor
factor          ::= simple { simple }
simple          ::= '(' expr ')' 
simple          ::= ID
simple          ::= INT
simple          ::= []
```

FIRST (expr) = { "\", "if", "(", ID, INT }

To do: introduce ":" for cons, and allow list constants like [1,2,3] and []

```
def length l = if (null l) then 0 else 1 + length (tail l)
```
