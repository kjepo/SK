# SK

A small implementation of David Turner's graph reduction algorithm from
"A new implementation technique for applicative languages", Software Practice
& Experience 1979.

I worked on this a little bit when I was a grad student at UCSC but didn't
implement the abstraction algorithm (a.k.a. lambda lifting).  Now, 32 years
later, I wrote it and 
the aim is to write a simple parser which can generate an abstract syntax tree
which is then rewritten to a combinator graph and translated to C code for
compilation and execution.

The program currently computes the factorial function by reducing a combinator
graph generated by the Haskell program `lift.hs`.

The input is a function definition fac = Î»x. if x=0 then 1 else x*fac(x-1) which is encoded
```
\x -> cond (eq x 0) 1 (times x (fac (minus x 1)))
```

This is represented as an abstract syntax tree:
```
Abs "x" (App (App (App (Var "cond") (App (App (Var "eq") (Var "x")) (Number 0))) (Number 1)) (App (App (Var "times") (Var "x")) (App (Var "fac") (App (App (Var "minus") (Var "x")) (Number 1)))))
```

The abstraction takes that and generates a combinator graph:
```
S (C (B cond (C (B eq I) 0)) 1) (S (B times I) (B fac (C (B minus I) 1)))
```

which is then simplified to
```
S (C (B cond (C eq 0)) 1) (S times (B fac (C minus 1)))
```

which is then printed as C-code:
```
Noderef facp = mkapply(mkapply(mkS(), mkapply(mkapply(mkC(), mkapply(mkapply(mkB(), mkCOND()), mkapply(mkapply(mkC(), mkEQ()), mknum(0)))), mknum(1))), mkapply(mkapply(mkS(), mkTIMES()), mkapply(mkapply(mkB(), fac), mkapply(mkapply(mkC(), mkMINUS()), mknum(1)))));
```

which I can insert in the `init` function in `sk.c` and compile and run and get a result.

My original paper listing from 1990 is scanned as a PDF file.
